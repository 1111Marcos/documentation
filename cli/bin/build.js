const fs = require('fs');
const path = require('path');
const yaml = require('yaml');
const mkdirp = require('mkdirp');
const {getReleases, CLI_NWO, CLI_URL} = require('../lib/releases.js')

const DEFAULT_TITLE = 'npm CLI'
const DEFAULT_SHORTNAME = 'CLI'

const REDIRECTS = {
    'index.mdx': [
        '/cli-documentation',
    ],
    'commands/index.mdx': [
        '/cli-documentation/cli',
        '/cli-documentation/cli-commands'
    ],
    'commands/npm-access.md': [
        '/cli-documentation/access',
    ],
    'commands/npm-install.md': [
        '/cli-documentation/install',
    ],
    'configuring-npm/index.mdx': [
        '/cli-documentation/configuring-npm',
        '/cli-documentation/files',
    ],
    'configuring-npm/folders.md': [
        '/files/folders',
        '/files/folders.html',
    ],
    'configuring-npm/npmrc.md': [
        '/cli-documentation/files/npmrc',
        '/files/npmrc',
        '/files/npmrc.html'
    ],
    'configuring-npm/package-json.md': [
        '/configuring-npm/package.json',
        '/creating-a-packge-json-file',
        '/files/package.json',
        '/files/package.json.html',
    ],
    'configuring-npm/package-lock-json.md': [
        '/files/package-lock.json',
        '/files/package-lock.json.html',
    ],
    'configuring-npm/package-locks.md': [
        '/files/package-locks',
        '/files/package-locks.html',
    ],
    'configuring-npm/shrinkwrap-json.md': [
        '/files/shrinkwrap.json',
        '/files/shrinkwrap.json.html',
    ],
    'using-npm/index.mdx': [
        '/cli-documentation/misc',
        '/cli-documentation/using-npm',
        '/misc/index.html',
    ],
    'using-npm/removal.md': [
        '/misc/removing-npm',
        '/misc/removing-npm.html',
    ],  
    'using-npm/scope.md': [
        '/using-npm/npm-scope',
    ],
};

const srcPath = (...paths) => path.resolve(__dirname, '..', '..', 'src', ...paths)

async function main () {
    const baseNavPath = srcPath('nav-base.yml');
    const fullNavPath = srcPath('gatsby-theme-doctornpm', 'nav.yml');

    const releases = await getReleases()

    for (const release of releases) {
        release.children = rewriteUrls(release, yaml.parse(release.nav))
        await fs.promises.rm(release.outputPath(), {force: true, recursive: true})
    }

    // merge the cli nav into the base nav for this repo
    const fullNav = updateNav(releases, yaml.parse(fs.readFileSync(baseNavPath, 'utf-8')))

    const pagePaths = releases.map((r) => copyDocs(r)).flat()
    const result = ensurePagesLinked(pagePaths, fullNav)

    if (result.success) {
        fs.writeFileSync(fullNavPath, [
            '# This file is automatically generated. Do not edit.',
            '# For registry content, edit `src/nav-base.yml` in this repository.',
            '# For CLI content, edit one of the following files:',
            ...releases.map((r) =>
                `# - npm@${r.version}: https://github.com/${CLI_NWO}/blob/${r.branch}/${r.navPath}`
            ),
            '',
            yaml.stringify(fullNav)
        ].join('\n'))
    }

   return result
}

function rewriteUrls(release, nodes) {
    nodes.map((n) => {
        const pagePath = n.url.startsWith('/') ? n.url.substring(1) : n.url;
        const data = translate(release, { path: pagePath });
        n.url = `${release.url}/${data.path}`;

        if (n.children) {
            rewriteUrls(release, n.children);
        }
    });
    return nodes
}

function translate(release, data) {
    if (!data.frontmatter) {
        data.frontmatter = { };
    }

    if (!data.frontmatter.redirect_from) {
        data.frontmatter.redirect_from = [ ];
    }

    let matches;

    if ((matches = data.path.match(/(?:(^|.*?)\/?)index(?:\.md(?:x)?)$/))) {
        if (release.default) {
            const [, section] = matches;

            data.frontmatter.redirect_from = section ? [
                `${section}`,
                `/cli/${section}`,
            ] : [
                `/cli`,
            ]
        }
    }

    else if (data.path.match(/^commands\/npm(?:\.md(?:x)?)?$/)) {
        if (release.default) {
            data.frontmatter.redirect_from = [
                `/cli/npm`,
                `/cli/npm.html`,
                `/cli/commands/npm`,
                `/cli-commands/npm`,
                `/cli-commands/npm.html`,
            ];
        }
    }

    else if ((matches = data.path.match(/^commands\/npm-(.*?)(?:\.md(?:x)?)?$/)) != null) {
        const [, command] = matches;

        if (release.default) {
            data.frontmatter.redirect_from = [
                `/cli/${command}`,
                `/cli/${command}.html`,
                `/cli/commands/${command}`,
                `/cli-commands/${command}`,
                `/cli-commands/${command}.html`,
                `/cli-commands/npm-${command}`,
            ];
        }
    }

    else if ((matches = data.path.match(/^(configuring-npm)\/(.*?)(?:\.md(?:x)?)?$/)) != null) {
        const [, path, page] = matches;

        if (release.default) {
            data.frontmatter.redirect_from = [
                `/${path}/${page}`,
                `/${path}/${page}.html`,
            ];
        }
    }

    else if ((matches = data.path.match(/^(using-npm)\/(.*?)(?:\.md(?:x)?)?$/)) != null) {
        const [, path, page] = matches;

        if (release.default) {
            data.frontmatter.redirect_from = [
                `/${path}/${page}`,
                `/${path}/${page}.html`,
                `/misc/${page}`,
                `/misc/${page}.html`,
            ];
        }
    }

    data.frontmatter.github_repo = CLI_NWO;
    data.frontmatter.github_branch = release.branch;
    data.frontmatter.github_path = release.githubPath(data.path);

    if (REDIRECTS[data.path] && release.default) {
        data.frontmatter.redirect_from.push(...REDIRECTS[data.path]);
    }
    
    if ((matches = data.path.match(/(?:(^|.*?)\/?)index(?:\.md(?:x)?)$/)) != null && !data.mdx) {
        // For virtual index pages (meaning they dont come from the cli
        // repo), we get the title from the nav section with a matching url.
        // Also point the edit link to the nav file, in case there are
        // typos or something to fix there.
        const [, section] = matches;

        data.frontmatter.title = section
            ? release.children.find((c) => path.basename(c.url) === section).title
            : DEFAULT_TITLE;
        data.frontmatter.github_path = release.navPath;
        data.mdx = '\n<Index depth="1" />\n';

    }

    if (data.mdx) {
        const replacer = (_, p1, p2) => `[${p1}](${CLI_URL}/${release.id}/${p2})`;

        data.mdx = data.mdx
            .replace(/@VERSION@/g, release.version)
            .replace(/\[([^\]]+)\]\(\/(commands\/[^)]+)\)/g, replacer)
            .replace(/\[([^\]]+)\]\(\/(configuring-npm\/[^)]+)\)/g, replacer)
            .replace(/\[([^\]]+)\]\(\/(using-npm\/[^)]+)\)/g, replacer);
    }

    if (data?.frontmatter?.redirect_from?.length === 0) {
        delete data.frontmatter.redirect_from
    }

    return data;
}

function ensurePagesLinked(pages, fullNav) {
    const result = {
        navOnly: {
            message: 'Included in navigation but do not exist:',
            paths: []
        },
        fsOnly: {
            message: 'Not included in navigation:',
            paths: []
        },
        success: true
    }

    const pagesMap = pages.reduce((acc, page) => {
        const file = path.join(path.sep, page).replace(/\.md$/, '');
        acc[file] = true
        return acc
    }, {})

    // identify nav items that aren't pages
    walkNavigation(fullNav, (n) => {
        if (!pagesMap[n.url]) {
            result.navOnly.paths.push(n.url)
            result.success = false;
        }
        delete pagesMap[n.url]
    });

    Object.keys(pagesMap).filter(p => !p.match("^(.*\/)?index\.md(?:x)?$")).forEach((page) => {
        result.fsOnly.paths.push(page)
        result.success = false;
    });

    return result;
}

function walkNavigation(nodes, fn) {
    nodes.forEach((n) => {
        if (!n.children && !n.variants && n.url.startsWith(`${CLI_URL}/`)) {
            fn(n);
        }

        if (n.variants) {
            walkNavigation(n.variants, fn);
        }

        if (n.children) {
            walkNavigation(n.children, fn);
        }
    })
}

function copyDocs(release, relativeDir) {
    let paths = [ ]

    const children = fs.readdirSync(release.contentPath(relativeDir));

    if (!children.includes("index.md") && !children.includes("index.mdx")) {
        children.push("index.mdx");
    }

    children.forEach((child) => {
        const relativeChild = path.join(...[relativeDir, child].filter(Boolean))
        const childPath = release.contentPath(relativeDir, child);
        const exists = fs.existsSync(childPath);

        if (exists && fs.lstatSync(childPath).isDirectory()) {
            paths.push(...copyDocs(release, relativeChild))
        }
        else {
            const contents = exists ? fs.readFileSync(childPath).toString() : '';
            const [, frontmatter = '', mdx = ''] = contents.match(/^---\n(.*)\n---\n(.*)/s) || []

            const fileData = translate(release, {
                path: relativeChild,
                frontmatter: yaml.parse(frontmatter),
                mdx
            });

            const output = "---\n" + yaml.stringify(fileData.frontmatter) + "---\n" + fileData.mdx;
            const outputPath = release.outputPath(fileData.path);

            mkdirp.sync(path.dirname(outputPath));
            fs.writeFileSync(outputPath, output);

            paths.push(release.urlPath(outputPath))
        }
    });

    return paths;
}

function updateNav(releases, baseNav) {
    const variants = releases.map((release) => ({
        title: release.title,
        shortName: release.id,
        url: release.url,
        default: release.default,
        children: release.children,
    }))

    baseNav.push({
        "title": DEFAULT_TITLE,
        "shortName": DEFAULT_SHORTNAME,
        "url": CLI_URL,
        variants,
    });

    return baseNav
}

main()
    .then(result => {
        if (!result.success) {
            process.exitCode = 1
            console.error('Error checking linked pages:')
            if (result.navOnly.paths.length) {
                console.error(result.navOnly.message)
                console.error(result.navOnly.paths.map((p) => `  ${p}`).join('\n'))
            }
            if (result.fsOnly.paths.length) {
                console.error(result.fsOnly.message)
                console.error(result.fsOnly.paths.map((p) => `  ${p}`).join('\n'))
            }
        }
    })
    .catch(err => {
        process.exitCode = 1
        console.error(err)
    })
